Final Portfolio Value: 7271566.71
Annual Return: 52.40%
Annual Volatility: 38.14%
Sharpe Ratio: 1.37
Maximum Drawdown: 56.81%

### æŒ‘æˆ˜å¤ç°80ç¯‡é‡åŒ–è®ºæ–‡ç¬¬63æœŸ-åˆ†æ•£äº¤æ˜“

#### ç­–ç•¥æ¦‚è¿° ğŸ’¡
åˆ†æ•£äº¤æ˜“åˆ©ç”¨æŒ‡æ•°æœŸæƒå’Œå•ä¸ªè‚¡ç¥¨æœŸæƒä¹‹é—´çš„éšå«æ³¢åŠ¨ç‡ä¸å®ç°æ³¢åŠ¨ç‡çš„å·®å¼‚æ¥è·åˆ©ã€‚è¿™ç§ç­–ç•¥åœ¨ä¸ªè‚¡æ³¢åŠ¨æ€§åˆ†æ•£æ—¶è¡¨ç°è‰¯å¥½ï¼Œè€Œåœ¨å¸‚åœºå‹åŠ›æ—¶æœŸï¼Œä¸ªè‚¡ç›¸å…³æ€§å¢åŠ æ—¶å¯èƒ½ä¼šå‡ºç°äºæŸã€‚

#### å…³é”®è¦ç‚¹ âœ¨
- åˆ†æå¸ˆå¯¹å…¬å¸æ”¶ç›Šé¢„æœŸçš„åˆ†æ­§åº¦ä¸æŒ‡æ•°æœŸæƒå’Œä¸ªè‚¡æœŸæƒçš„éšå«æ³¢åŠ¨ç‡å¯†åˆ‡ç›¸å…³ã€‚
- äº¤æ˜“åœ¨ä¸ªè‚¡æ³¢åŠ¨æ€§åˆ†æ•£æ—¶è·åˆ©ï¼Œåœ¨å¸‚åœºå‹åŠ›æ—¶æœŸäºæŸã€‚

#### äº¤æ˜“èµ„äº§ ğŸ“¦
äº¤æ˜“æ ‡çš„ä¸ºS&P 100æŒ‡æ•°ä¸­çš„è‚¡ç¥¨æœŸæƒå’ŒæŒ‡æ•°æœŸæƒã€‚

#### äº¤æ˜“ç­–ç•¥ ğŸ› ï¸
- å–å‡ºS&P 100æŒ‡æ•°æœŸæƒã€‚
- ä¹°å…¥åˆ†æå¸ˆåˆ†æ­§åº¦æœ€é«˜çš„ä¸ªè‚¡æœŸæƒã€‚

#### äº¤æ˜“ä¿¡å· ğŸ“¢
- æ¯æœˆæ ¹æ®I/B/E/Sæ•°æ®åº“ä¸­çš„åˆ†æå¸ˆæ”¶ç›Šé¢„æœŸåˆ†æ­§åº¦å¯¹è‚¡ç¥¨è¿›è¡Œæ’åºã€‚
- ä¹°å…¥åˆ†æ­§åº¦æœ€é«˜çš„è‚¡ç¥¨æœŸæƒï¼ˆçœ‹è·ŒæœŸæƒï¼‰ã€‚
- å–å‡ºS&P 100æŒ‡æ•°æœŸæƒï¼ŒBlack-Scholes DeltaèŒƒå›´ä¸º-0.8è‡³-0.2ã€‚

#### è®ºæ–‡å‡ºå¤„ ğŸ“š
è¿™é¡¹ç­–ç•¥åŸºäºåˆ†æå¸ˆé¢„æœŸåˆ†æ­§ä¸éšå«æ³¢åŠ¨ç‡çš„å…³ç³»ï¼Œç›¸å…³ç ”ç©¶åŒ…æ‹¬Dietherç­‰ï¼ˆ2002ï¼‰åœ¨ã€Šé‡‘èå­¦æŠ¥ã€‹ä¸­å‘è¡¨çš„ã€ŠDifferences of Opinion and the Cross Section of Stock Returnsã€‹ä»¥åŠBanerjeeç­‰ï¼ˆ2009ï¼‰åœ¨ã€Šé‡‘èç ”ç©¶è¯„è®ºã€‹ä¸­å‘è¡¨çš„ã€ŠPrice Drift as an Outcome of Differences in Higher-Order Beliefsã€‹ã€9â€ sourceã€‘ã€8â€ sourceã€‘ã€‚

```Python
import backtrader as bt
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

def get_stock_data(ticker, start_date, end_date):
    stock = yf.Ticker(ticker)
    hist = stock.history(start=start_date, end=end_date)
    
    # è®¡ç®—å†å²æ³¢åŠ¨ç‡ï¼ˆ20å¤©ï¼‰
    hist['Returns'] = hist['Close'].pct_change()
    hist['Volatility'] = hist['Returns'].rolling(window=20).std() * np.sqrt(252)
    
    # è·å–åˆ†æå¸ˆç›®æ ‡ä»·
    try:
        target_price = stock.info['targetMeanPrice']
    except:
        target_price = hist['Close'].mean()  # å¦‚æœæ— æ³•è·å–ç›®æ ‡ä»·ï¼Œä½¿ç”¨å¹³å‡ä»·æ ¼ä½œä¸ºæ›¿ä»£
    
    # è®¡ç®—å½“å‰ä»·æ ¼ä¸ç›®æ ‡ä»·ä¹‹é—´çš„å·®å¼‚ä½œä¸ºåˆ†æ­§åº¦çš„ä»£ç†
    hist['PriceDeviation'] = abs(hist['Close'] - target_price) / hist['Close']
    
    # åˆ é™¤NaNå€¼
    hist.dropna(inplace=True)
    
    return hist

class PandasDataWithDeviation(bt.feeds.PandasData):
    lines = ('PriceDeviation', 'Volatility',)
    params = (('PriceDeviation', -1), ('Volatility', -1),)

class DispersionTradingStrategy(bt.Strategy):
    params = (
        ('rebalance_months', [1, 4, 7, 10]),  # æ¯å¹´1æœˆã€4æœˆã€7æœˆå’Œ10æœˆè°ƒæ•´
        ('top_n', 5),  # é€‰æ‹©åˆ†æ­§åº¦æœ€é«˜çš„å‰Nåªè‚¡ç¥¨
    )

    def __init__(self):
        self.sp100 = self.getdatabyname('SPY')  # S&P 100 æŒ‡æ•°
        self.stocks = [d for d in self.datas if d._name != 'SPY']
        self.rebalance_date = None
        self.order = None  # è·Ÿè¸ªå½“å‰è®¢å•

    def next(self):
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„è®¢å•
        if self.order:
            return

        # æ£€æŸ¥æ˜¯å¦æ˜¯è°ƒä»“æœˆä»½çš„ç¬¬ä¸€ä¸ªäº¤æ˜“æ—¥
        if self.data.datetime.date(0).month in self.params.rebalance_months and self.data.datetime.date(0).day <= 5:
            self.rebalance_date = self.data.datetime.date(0)
            self.rebalance_portfolio()

    def rebalance_portfolio(self):
        self.log(f"Attempting to rebalance portfolio on {self.rebalance_date}")

        # è·å–å½“å‰çš„ä»·æ ¼åç¦»åº¦å’Œæ³¢åŠ¨ç‡æ•°æ®
        deviation_data = self.get_deviation_data()
        
        if deviation_data is not None and not deviation_data.empty:
            self.log(f"Deviation data: {deviation_data}")
            
            # æŒ‰ä»·æ ¼åç¦»åº¦å’Œæ³¢åŠ¨ç‡çš„ç»„åˆæŒ‡æ ‡å¯¹è‚¡ç¥¨è¿›è¡Œæ’åº
            deviation_data['CombinedScore'] = deviation_data['PriceDeviation'] * deviation_data['Volatility']
            deviation_data = deviation_data.sort_values(by='CombinedScore', ascending=False)
            
            # é€‰æ‹©å¾—åˆ†æœ€é«˜çš„è‚¡ç¥¨
            high_deviation_stocks = deviation_data.head(self.params.top_n)['Ticker'].tolist()
            self.log(f"Selected stocks: {high_deviation_stocks}")

            # æ¸…ä»“
            for data in self.datas:
                if self.getposition(data).size:
                    self.order = self.close(data=data)
                    self.log(f"Closing position for {data._name}")

            # åšç©ºS&P 100æŒ‡æ•°
            self.order = self.sell(data=self.sp100)
            self.log(f"Shorting SPY")

            # ä¹°å…¥å¾—åˆ†æœ€é«˜çš„è‚¡ç¥¨
            weight = self.broker.getvalue() / len(high_deviation_stocks)
            for ticker in high_deviation_stocks:
                data = self.getdatabyname(ticker)
                size = int(weight / data.close[0])
                self.order = self.buy(data=data, size=size)
                self.log(f"Buy order placed for {ticker}, size: {size}")
        else:
            self.log("No valid deviation data available for rebalancing")

    def get_deviation_data(self):
        deviation_data = {'Ticker': [], 'PriceDeviation': [], 'Volatility': []}
        for stock in self.stocks:
            ticker = stock._name
            deviation_data['Ticker'].append(ticker)
            deviation_data['PriceDeviation'].append(stock.PriceDeviation[0])
            deviation_data['Volatility'].append(stock.Volatility[0])
        return pd.DataFrame(deviation_data)

    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        print(f'{dt.isoformat()}: {txt}')

class PerformanceAnalyzer(bt.Analyzer):
    def __init__(self):
        self.rets = []

    def next(self):
        self.rets.append(self.strategy.broker.getvalue())

    def get_analysis(self):
        returns = np.diff(self.rets) / self.rets[:-1]
        annual_return = np.mean(returns) * 252
        annual_volatility = np.std(returns) * np.sqrt(252)
        sharpe_ratio = annual_return / annual_volatility if annual_volatility != 0 else 0

        # æœ€å¤§å›æ’¤è®¡ç®—
        cum_returns = np.maximum.accumulate(self.rets)
        drawdowns = (cum_returns - self.rets) / cum_returns
        max_drawdown = np.max(drawdowns)

        return {
            'portfolio_value': self.rets[-1],
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }

if __name__ == '__main__':
    cerebro = bt.Cerebro()

    # S&P 100 æˆåˆ†è‚¡ (è¿™é‡Œç”¨éƒ¨åˆ†è‚¡ç¥¨ä»£æ›¿ï¼Œå·²åˆ é™¤ 'FB')
    tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'JPM', 'JNJ', 'V', 'PG', 'UNH', 'HD', 'MA', 'DIS', 'PYPL', 'BAC', 'CMCSA', 'ADBE', 'CRM']

    start_date = "2020-01-01"
    end_date = "2024-07-01"

    # æ·»åŠ S&P 100æŒ‡æ•° (ç”¨SPY ETFä»£æ›¿)
    sp100_data = PandasDataWithDeviation(dataname=get_stock_data('SPY', start_date, end_date), name='SPY')
    cerebro.adddata(sp100_data)

    # æ·»åŠ ä¸ªè‚¡æ•°æ®
    for ticker in tickers:
        data = PandasDataWithDeviation(dataname=get_stock_data(ticker, start_date, end_date), name=ticker)
        cerebro.adddata(data)

    cerebro.addstrategy(DispersionTradingStrategy)
    
    cerebro.broker.set_cash(1000000)
    cerebro.addsizer(bt.sizers.FixedSize, stake=100)

    cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')

    print('Initial Portfolio Value: %.2f' % cerebro.broker.getvalue())
    results = cerebro.run()
    strat = results[0]
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

    performance = strat.analyzers.performance.get_analysis()
    print('Annual Return: {:.2f}%'.format(performance['annual_return'] * 100))
    print('Annual Volatility: {:.2f}%'.format(performance['annual_volatility'] * 100))
    print('Sharpe Ratio: {:.2f}'.format(performance['sharpe_ratio']))
    print('Maximum Drawdown: {:.2f}%'.format(performance['max_drawdown'] * 100))

    cerebro.plot()
```